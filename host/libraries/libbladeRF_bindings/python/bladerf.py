import enum
import collections

import cffi

ffi = cffi.FFI()

# The cdef string is auto-generated by _import_header.py
ffi.cdef("""
    /* Generated from libbladeRF.h by _import_header.py */
    struct bladerf;
    typedef enum
    {
        BLADERF_BACKEND_ANY,
        BLADERF_BACKEND_LINUX,
        BLADERF_BACKEND_LIBUSB,
        BLADERF_BACKEND_CYPRESS,
        BLADERF_BACKEND_DUMMY = 100
    } bladerf_backend;
    struct bladerf_devinfo
    {
        bladerf_backend backend;
        char serial[33];
        uint8_t usb_bus;
        uint8_t usb_addr;
        unsigned int instance;
    };
    int bladerf_open(struct bladerf **device, const char
        *device_identifier);
    void bladerf_close(struct bladerf *device);
    int bladerf_open_with_devinfo(struct bladerf **device, struct
        bladerf_devinfo *devinfo);
    int bladerf_get_device_list(struct bladerf_devinfo **devices);
    void bladerf_free_device_list(struct bladerf_devinfo *devices);
    void bladerf_init_devinfo(struct bladerf_devinfo *info);
    int bladerf_get_devinfo(struct bladerf *dev, struct bladerf_devinfo
        *info);
    int bladerf_get_devinfo_from_str(const char *devstr, struct
        bladerf_devinfo *info);
    bool bladerf_devinfo_matches(const struct bladerf_devinfo *a, const
        struct bladerf_devinfo *b);
    bool bladerf_devstr_matches(const char *dev_str, struct
        bladerf_devinfo *info);
    const char *bladerf_backend_str(bladerf_backend backend);
    void bladerf_set_usb_reset_on_open(bool enabled);
    struct bladerf_version
    {
        uint16_t major;
        uint16_t minor;
        uint16_t patch;
        const char *describe;
    };
    typedef enum
    {
        BLADERF_FPGA_UNKNOWN = 0,
        BLADERF_FPGA_40KLE = 40,
        BLADERF_FPGA_115KLE = 115,
        BLADERF_FPGA_A4 = 49,
        BLADERF_FPGA_A9 = 301
    } bladerf_fpga_size;
    typedef enum
    {
        BLADERF_DEVICE_SPEED_UNKNOWN,
        BLADERF_DEVICE_SPEED_HIGH,
        BLADERF_DEVICE_SPEED_SUPER
    } bladerf_dev_speed;
    int bladerf_get_serial(struct bladerf *dev, char *serial);
    int bladerf_get_fpga_size(struct bladerf *dev, bladerf_fpga_size
        *size);
    int bladerf_fw_version(struct bladerf *dev, struct bladerf_version
        *version);
    int bladerf_is_fpga_configured(struct bladerf *dev);
    int bladerf_fpga_version(struct bladerf *dev, struct bladerf_version
        *version);
    bladerf_dev_speed bladerf_device_speed(struct bladerf *dev);
    const char *bladerf_get_board_name(struct bladerf *dev);
    size_t bladerf_get_channel_count(struct bladerf *dev, bool tx);
    typedef int bladerf_channel;
    typedef bladerf_channel bladerf_module;
    struct bladerf_range
    {
        int64_t min;
        int64_t max;
        int64_t step;
        float scale;
    };
    typedef enum
    {
        BLADERF_GAIN_DEFAULT,
        BLADERF_GAIN_MGC,
        BLADERF_GAIN_FASTATTACK_AGC,
        BLADERF_GAIN_SLOWATTACK_AGC,
        BLADERF_GAIN_HYBRID_AGC
    } bladerf_gain_mode;
    struct bladerf_gain_modes
    {
        const char *name;
        bladerf_gain_mode mode;
    };
    int bladerf_set_gain(struct bladerf *dev, bladerf_channel ch, int
        gain);
    int bladerf_get_gain(struct bladerf *dev, bladerf_channel ch, int
        *gain);
    int bladerf_set_gain_mode(struct bladerf *dev, bladerf_channel ch,
        bladerf_gain_mode mode);
    int bladerf_get_gain_mode(struct bladerf *dev, bladerf_channel ch,
        bladerf_gain_mode *mode);
    int bladerf_get_gain_modes(struct bladerf *dev, bladerf_channel ch,
        const struct bladerf_gain_modes **modes);
    int bladerf_get_gain_range(struct bladerf *dev, bladerf_channel ch,
        struct bladerf_range *range);
    int bladerf_set_gain_stage(struct bladerf *dev, bladerf_channel ch,
        const char *stage, int gain);
    int bladerf_get_gain_stage(struct bladerf *dev, bladerf_channel ch,
        const char *stage, int *gain);
    int bladerf_get_gain_stage_range(struct bladerf *dev, bladerf_channel
        ch, const char *stage, struct bladerf_range *range);
    int bladerf_get_gain_stages(struct bladerf *dev, bladerf_channel ch,
        const char **stages, unsigned int count);
    struct bladerf_rational_rate
    {
        uint64_t integer;
        uint64_t num;
        uint64_t den;
    };
    int bladerf_set_sample_rate(struct bladerf *dev, bladerf_channel ch,
        unsigned int rate, unsigned int *actual);
    int bladerf_set_rational_sample_rate(struct bladerf *dev,
        bladerf_channel ch, struct bladerf_rational_rate *rate, struct
        bladerf_rational_rate *actual);
    int bladerf_get_sample_rate(struct bladerf *dev, bladerf_channel ch,
        unsigned int *rate);
    int bladerf_get_sample_rate_range(struct bladerf *dev, bladerf_channel
        ch, struct bladerf_range *range);
    int bladerf_get_rational_sample_rate(struct bladerf *dev,
        bladerf_channel ch, struct bladerf_rational_rate *rate);
    int bladerf_set_bandwidth(struct bladerf *dev, bladerf_channel ch,
        unsigned int bandwidth, unsigned int *actual);
    int bladerf_get_bandwidth(struct bladerf *dev, bladerf_channel ch,
        unsigned int *bandwidth);
    int bladerf_get_bandwidth_range(struct bladerf *dev, bladerf_channel
        ch, struct bladerf_range *range);
    int bladerf_select_band(struct bladerf *dev, bladerf_channel ch,
        uint64_t frequency);
    int bladerf_set_frequency(struct bladerf *dev, bladerf_channel ch,
        uint64_t frequency);
    int bladerf_get_frequency(struct bladerf *dev, bladerf_channel ch,
        uint64_t *frequency);
    int bladerf_get_frequency_range(struct bladerf *dev, bladerf_channel
        ch, struct bladerf_range *range);
    int bladerf_set_rf_port(struct bladerf *dev, bladerf_channel ch, const
        char *port);
    int bladerf_get_rf_port(struct bladerf *dev, bladerf_channel ch, const
        char **port);
    int bladerf_get_rf_ports(struct bladerf *dev, bladerf_channel ch,
        const char **ports, unsigned int count);
    typedef enum
    {
        BLADERF_LB_FIRMWARE = 1,
        BLADERF_LB_BB_TXLPF_RXVGA2,
        BLADERF_LB_BB_TXVGA1_RXVGA2,
        BLADERF_LB_BB_TXLPF_RXLPF,
        BLADERF_LB_BB_TXVGA1_RXLPF,
        BLADERF_LB_RF_LNA1,
        BLADERF_LB_RF_LNA2,
        BLADERF_LB_RF_LNA3,
        BLADERF_LB_NONE,
        BLADERF_LB_AD9361_BIST
    } bladerf_loopback;
    struct bladerf_loopback_modes
    {
        const char *name;
        bladerf_loopback mode;
    };
    int bladerf_get_loopback_modes(struct bladerf *dev, const struct
        bladerf_loopback_modes **modes);
    bool bladerf_is_loopback_mode_supported(struct bladerf *dev,
        bladerf_loopback mode);
    int bladerf_set_loopback(struct bladerf *dev, bladerf_loopback lb);
    int bladerf_get_loopback(struct bladerf *dev, bladerf_loopback *lb);
    typedef enum
    {
        BLADERF_TRIGGER_ROLE_INVALID = -1,
        BLADERF_TRIGGER_ROLE_DISABLED,
        BLADERF_TRIGGER_ROLE_MASTER,
        BLADERF_TRIGGER_ROLE_SLAVE
    } bladerf_trigger_role;
    typedef enum
    {
        BLADERF_TRIGGER_INVALID = -1,
        BLADERF_TRIGGER_J71_4,
        BLADERF_TRIGGER_USER_0 = 128,
        BLADERF_TRIGGER_USER_1,
        BLADERF_TRIGGER_USER_2,
        BLADERF_TRIGGER_USER_3,
        BLADERF_TRIGGER_USER_4,
        BLADERF_TRIGGER_USER_5,
        BLADERF_TRIGGER_USER_6,
        BLADERF_TRIGGER_USER_7
    } bladerf_trigger_signal;
    struct bladerf_trigger
    {
        bladerf_channel channel;
        bladerf_trigger_role role;
        bladerf_trigger_signal signal;
        uint64_t options;
    };
    int bladerf_trigger_init(struct bladerf *dev, bladerf_channel ch,
        bladerf_trigger_signal signal, struct bladerf_trigger *trigger);
    int bladerf_trigger_arm(struct bladerf *dev, const struct
        bladerf_trigger *trigger, bool arm, uint64_t resv1, uint64_t resv2);
    int bladerf_trigger_fire(struct bladerf *dev, const struct
        bladerf_trigger *trigger);
    int bladerf_trigger_state(struct bladerf *dev, const struct
        bladerf_trigger *trigger, bool *is_armed, bool *has_fired, bool
        *fire_requested, uint64_t *resv1, uint64_t *resv2);
    typedef enum
    {
        BLADERF_RX_MUX_INVALID = -1,
        BLADERF_RX_MUX_BASEBAND = 0x0,
        BLADERF_RX_MUX_12BIT_COUNTER = 0x1,
        BLADERF_RX_MUX_32BIT_COUNTER = 0x2,
        BLADERF_RX_MUX_DIGITAL_LOOPBACK = 0x4
    } bladerf_rx_mux;
    int bladerf_set_rx_mux(struct bladerf *dev, bladerf_rx_mux mux);
    int bladerf_get_rx_mux(struct bladerf *dev, bladerf_rx_mux *mode);
    struct bladerf_quick_tune
    {
        union
        {
            struct
            {
                uint8_t freqsel;
                uint8_t vcocap;
                uint16_t nint;
                uint32_t nfrac;
                uint8_t flags;
            };
            struct
            {
                void *tbd;
            };
        };
    };
    int bladerf_schedule_retune(struct bladerf *dev, bladerf_channel ch,
        uint64_t timestamp, uint64_t frequency, struct bladerf_quick_tune
        *quick_tune);
    int bladerf_cancel_scheduled_retunes(struct bladerf *dev,
        bladerf_channel ch);
    int bladerf_get_quick_tune(struct bladerf *dev, bladerf_channel ch,
        struct bladerf_quick_tune *quick_tune);
    typedef enum
    {
        BLADERF_CORR_DCOFF_I,
        BLADERF_CORR_DCOFF_Q,
        BLADERF_CORR_PHASE,
        BLADERF_CORR_GAIN
    } bladerf_correction;
    int bladerf_set_correction(struct bladerf *dev, bladerf_channel ch,
        bladerf_correction corr, int16_t value);
    int bladerf_get_correction(struct bladerf *dev, bladerf_channel ch,
        bladerf_correction corr, int16_t *value);
    typedef enum
    {
        BLADERF_RX = 0,
        BLADERF_TX = 1
    } bladerf_direction;
    typedef enum
    {
        BLADERF_RX_X1 = 0,
        BLADERF_TX_X1 = 1,
        BLADERF_RX_X2 = 2,
        BLADERF_TX_X2 = 3
    } bladerf_channel_layout;
    typedef enum
    {
        BLADERF_FORMAT_SC16_Q11,
        BLADERF_FORMAT_SC16_Q11_META
    } bladerf_format;
    struct bladerf_metadata
    {
        uint64_t timestamp;
        uint32_t flags;
        uint32_t status;
        unsigned int actual_count;
        uint8_t reserved[32];
    };
    int bladerf_interleave_stream_buffer(bladerf_channel_layout layout,
        bladerf_format format, unsigned int buffer_size, void *samples);
    int bladerf_deinterleave_stream_buffer(bladerf_channel_layout layout,
        bladerf_format format, unsigned int buffer_size, void *samples);
    int bladerf_enable_module(struct bladerf *dev, bladerf_channel ch,
        bool enable);
    int bladerf_get_timestamp(struct bladerf *dev, bladerf_direction dir,
        uint64_t *value);
    int bladerf_sync_config(struct bladerf *dev, bladerf_channel_layout
        layout, bladerf_format format, unsigned int num_buffers, unsigned int
        buffer_size, unsigned int num_transfers, unsigned int stream_timeout);
    int bladerf_sync_tx(struct bladerf *dev, const void *samples, unsigned
        int num_samples, struct bladerf_metadata *metadata, unsigned int
        timeout_ms);
    int bladerf_sync_rx(struct bladerf *dev, void *samples, unsigned int
        num_samples, struct bladerf_metadata *metadata, unsigned int
        timeout_ms);
    struct bladerf_stream;
    typedef void *(*bladerf_stream_cb)(struct bladerf *dev, struct
        bladerf_stream *stream, struct bladerf_metadata *meta, void *samples,
        size_t num_samples, void *user_data);
    int bladerf_init_stream(struct bladerf_stream **stream, struct bladerf
        *dev, bladerf_stream_cb callback, void ***buffers, size_t num_buffers,
        bladerf_format format, size_t samples_per_buffer, size_t
        num_transfers, void *user_data);
    int bladerf_stream(struct bladerf_stream *stream,
        bladerf_channel_layout layout);
    int bladerf_submit_stream_buffer(struct bladerf_stream *stream, void
        *buffer, unsigned int timeout_ms);
    int bladerf_submit_stream_buffer_nb(struct bladerf_stream *stream,
        void *buffer);
    void bladerf_deinit_stream(struct bladerf_stream *stream);
    int bladerf_set_stream_timeout(struct bladerf *dev, bladerf_direction
        dir, unsigned int timeout);
    int bladerf_get_stream_timeout(struct bladerf *dev, bladerf_direction
        dir, unsigned int *timeout);
    int bladerf_flash_firmware(struct bladerf *dev, const char *firmware);
    int bladerf_load_fpga(struct bladerf *dev, const char *fpga);
    int bladerf_flash_fpga(struct bladerf *dev, const char *fpga_image);
    int bladerf_erase_stored_fpga(struct bladerf *dev);
    int bladerf_device_reset(struct bladerf *dev);
    int bladerf_get_fw_log(struct bladerf *dev, const char *filename);
    int bladerf_jump_to_bootloader(struct bladerf *dev);
    int bladerf_get_bootloader_list(struct bladerf_devinfo **list);
    int bladerf_load_fw_from_bootloader(const char *device_identifier,
        bladerf_backend backend, uint8_t bus, uint8_t addr, const char *file);
    typedef enum
    {
        BLADERF_IMAGE_TYPE_INVALID = -1,
        BLADERF_IMAGE_TYPE_RAW,
        BLADERF_IMAGE_TYPE_FIRMWARE,
        BLADERF_IMAGE_TYPE_FPGA_40KLE,
        BLADERF_IMAGE_TYPE_FPGA_115KLE,
        BLADERF_IMAGE_TYPE_CALIBRATION,
        BLADERF_IMAGE_TYPE_RX_DC_CAL,
        BLADERF_IMAGE_TYPE_TX_DC_CAL,
        BLADERF_IMAGE_TYPE_RX_IQ_CAL,
        BLADERF_IMAGE_TYPE_TX_IQ_CAL
    } bladerf_image_type;
    struct bladerf_image
    {
        char magic[8]; /* Original: char magic[7 + 1]; */
        uint8_t checksum[32];
        struct bladerf_version version;
        uint64_t timestamp;
        char serial[34]; /* Original: char serial[33 + 1]; */
        char reserved[128];
        bladerf_image_type type;
        uint32_t address;
        uint32_t length;
        uint8_t *data;
    };
    struct bladerf_image *bladerf_alloc_image(bladerf_image_type type,
        uint32_t address, uint32_t length);
    struct bladerf_image *bladerf_alloc_cal_image(bladerf_fpga_size
        fpga_size, uint16_t vctcxo_trim);
    void bladerf_free_image(struct bladerf_image *image);
    int bladerf_image_write(struct bladerf_image *image, const char
        *file);
    int bladerf_image_read(struct bladerf_image *image, const char *file);
    typedef enum
    {
        BLADERF_VCTCXO_TAMER_INVALID = -1,
        BLADERF_VCTCXO_TAMER_DISABLED = 0,
        BLADERF_VCTCXO_TAMER_1_PPS = 1,
        BLADERF_VCTCXO_TAMER_10_MHZ = 2
    } bladerf_vctcxo_tamer_mode;
    int bladerf_set_vctcxo_tamer_mode(struct bladerf *dev,
        bladerf_vctcxo_tamer_mode mode);
    int bladerf_get_vctcxo_tamer_mode(struct bladerf *dev,
        bladerf_vctcxo_tamer_mode *mode);
    int bladerf_get_vctcxo_trim(struct bladerf *dev, uint16_t *trim);
    int bladerf_trim_dac_write(struct bladerf *dev, uint16_t val);
    int bladerf_trim_dac_read(struct bladerf *dev, uint16_t *val);
    typedef enum
    {
        BLADERF_TUNING_MODE_INVALID = -1,
        BLADERF_TUNING_MODE_HOST,
        BLADERF_TUNING_MODE_FPGA
    } bladerf_tuning_mode;
    int bladerf_set_tuning_mode(struct bladerf *dev, bladerf_tuning_mode
        mode);
    int bladerf_get_tuning_mode(struct bladerf *dev, bladerf_tuning_mode
        *mode);
    int bladerf_read_trigger(struct bladerf *dev, bladerf_channel ch,
        bladerf_trigger_signal signal, uint8_t *val);
    int bladerf_write_trigger(struct bladerf *dev, bladerf_channel ch,
        bladerf_trigger_signal signal, uint8_t val);
    int bladerf_config_gpio_read(struct bladerf *dev, uint32_t *val);
    int bladerf_config_gpio_write(struct bladerf *dev, uint32_t val);
    int bladerf_erase_flash(struct bladerf *dev, uint32_t erase_block,
        uint32_t count);
    int bladerf_read_flash(struct bladerf *dev, uint8_t *buf, uint32_t
        page, uint32_t count);
    int bladerf_write_flash(struct bladerf *dev, const uint8_t *buf,
        uint32_t page, uint32_t count);
    typedef enum
    {
        BLADERF_XB_NONE = 0,
        BLADERF_XB_100,
        BLADERF_XB_200,
        BLADERF_XB_300
    } bladerf_xb;
    int bladerf_expansion_attach(struct bladerf *dev, bladerf_xb xb);
    int bladerf_expansion_get_attached(struct bladerf *dev, bladerf_xb
        *xb);
    typedef enum
    {
        BLADERF_LOG_LEVEL_VERBOSE,
        BLADERF_LOG_LEVEL_DEBUG,
        BLADERF_LOG_LEVEL_INFO,
        BLADERF_LOG_LEVEL_WARNING,
        BLADERF_LOG_LEVEL_ERROR,
        BLADERF_LOG_LEVEL_CRITICAL,
        BLADERF_LOG_LEVEL_SILENT
    } bladerf_log_level;
    void bladerf_log_set_verbosity(bladerf_log_level level);
    void bladerf_version(struct bladerf_version *version);
    const char *bladerf_strerror(int error);
    typedef enum
    {
        BLADERF_LNA_GAIN_UNKNOWN,
        BLADERF_LNA_GAIN_BYPASS,
        BLADERF_LNA_GAIN_MID,
        BLADERF_LNA_GAIN_MAX
    } bladerf_lna_gain;
    int bladerf_set_txvga2(struct bladerf *dev, int gain);
    int bladerf_get_txvga2(struct bladerf *dev, int *gain);
    int bladerf_set_txvga1(struct bladerf *dev, int gain);
    int bladerf_get_txvga1(struct bladerf *dev, int *gain);
    int bladerf_set_lna_gain(struct bladerf *dev, bladerf_lna_gain gain);
    int bladerf_get_lna_gain(struct bladerf *dev, bladerf_lna_gain *gain);
    int bladerf_set_rxvga1(struct bladerf *dev, int gain);
    int bladerf_get_rxvga1(struct bladerf *dev, int *gain);
    int bladerf_set_rxvga2(struct bladerf *dev, int gain);
    int bladerf_get_rxvga2(struct bladerf *dev, int *gain);
    typedef enum
    {
        BLADERF_SAMPLING_UNKNOWN,
        BLADERF_SAMPLING_INTERNAL,
        BLADERF_SAMPLING_EXTERNAL
    } bladerf_sampling;
    int bladerf_set_sampling(struct bladerf *dev, bladerf_sampling
        sampling);
    int bladerf_get_sampling(struct bladerf *dev, bladerf_sampling
        *sampling);
    typedef enum
    {
        BLADERF_LPF_NORMAL,
        BLADERF_LPF_BYPASSED,
        BLADERF_LPF_DISABLED
    } bladerf_lpf_mode;
    int bladerf_set_lpf_mode(struct bladerf *dev, bladerf_channel ch,
        bladerf_lpf_mode mode);
    int bladerf_get_lpf_mode(struct bladerf *dev, bladerf_channel ch,
        bladerf_lpf_mode *mode);
    typedef enum
    {
        BLADERF_SMB_MODE_INVALID = -1,
        BLADERF_SMB_MODE_DISABLED,
        BLADERF_SMB_MODE_OUTPUT,
        BLADERF_SMB_MODE_INPUT,
        BLADERF_SMB_MODE_UNAVAILBLE
    } bladerf_smb_mode;
    int bladerf_set_smb_mode(struct bladerf *dev, bladerf_smb_mode mode);
    int bladerf_get_smb_mode(struct bladerf *dev, bladerf_smb_mode *mode);
    int bladerf_set_rational_smb_frequency(struct bladerf *dev, struct
        bladerf_rational_rate *rate, struct bladerf_rational_rate *actual);
    int bladerf_set_smb_frequency(struct bladerf *dev, uint32_t rate,
        uint32_t *actual);
    int bladerf_get_rational_smb_frequency(struct bladerf *dev, struct
        bladerf_rational_rate *rate);
    int bladerf_get_smb_frequency(struct bladerf *dev, unsigned int
        *rate);
    int bladerf_expansion_gpio_read(struct bladerf *dev, uint32_t *val);
    int bladerf_expansion_gpio_write(struct bladerf *dev, uint32_t val);
    int bladerf_expansion_gpio_masked_write(struct bladerf *dev, uint32_t
        mask, uint32_t value);
    int bladerf_expansion_gpio_dir_read(struct bladerf *dev, uint32_t
        *outputs);
    int bladerf_expansion_gpio_dir_write(struct bladerf *dev, uint32_t
        outputs);
    int bladerf_expansion_gpio_dir_masked_write(struct bladerf *dev,
        uint32_t mask, uint32_t outputs);
    typedef enum
    {
        BLADERF_XB200_50M = 0,
        BLADERF_XB200_144M,
        BLADERF_XB200_222M,
        BLADERF_XB200_CUSTOM,
        BLADERF_XB200_AUTO_1DB,
        BLADERF_XB200_AUTO_3DB
    } bladerf_xb200_filter;
    typedef enum
    {
        BLADERF_XB200_BYPASS = 0,
        BLADERF_XB200_MIX
    } bladerf_xb200_path;
    typedef enum
    {
        BLADERF_XB300_TRX_INVAL = -1,
        BLADERF_XB300_TRX_TX = 0,
        BLADERF_XB300_TRX_RX,
        BLADERF_XB300_TRX_UNSET
    } bladerf_xb300_trx;
    typedef enum
    {
        BLADERF_XB300_AMP_INVAL = -1,
        BLADERF_XB300_AMP_PA = 0,
        BLADERF_XB300_AMP_LNA,
        BLADERF_XB300_AMP_PA_AUX
    } bladerf_xb300_amplifier;
    int bladerf_xb200_set_filterbank(struct bladerf *dev, bladerf_channel
        ch, bladerf_xb200_filter filter);
    int bladerf_xb200_get_filterbank(struct bladerf *dev, bladerf_channel
        ch, bladerf_xb200_filter *filter);
    int bladerf_xb200_set_path(struct bladerf *dev, bladerf_channel ch,
        bladerf_xb200_path path);
    int bladerf_xb200_get_path(struct bladerf *dev, bladerf_channel ch,
        bladerf_xb200_path *path);
    int bladerf_xb300_set_trx(struct bladerf *dev, bladerf_xb300_trx trx);
    int bladerf_xb300_get_trx(struct bladerf *dev, bladerf_xb300_trx
        *trx);
    int bladerf_xb300_set_amplifier_enable(struct bladerf *dev,
        bladerf_xb300_amplifier amp, bool enable);
    int bladerf_xb300_get_amplifier_enable(struct bladerf *dev,
        bladerf_xb300_amplifier amp, bool *enable);
    int bladerf_xb300_get_output_power(struct bladerf *dev, float *val);
    typedef enum
    {
        BLADERF_DC_CAL_INVALID = -1,
        BLADERF_DC_CAL_LPF_TUNING,
        BLADERF_DC_CAL_TX_LPF,
        BLADERF_DC_CAL_RX_LPF,
        BLADERF_DC_CAL_RXVGA2
    } bladerf_cal_module;
    int bladerf_calibrate_dc(struct bladerf *dev, bladerf_cal_module
        module);
    int bladerf_dac_write(struct bladerf *dev, uint16_t val);
    int bladerf_dac_read(struct bladerf *dev, uint16_t *val);
    int bladerf_si5338_read(struct bladerf *dev, uint8_t address, uint8_t
        *val);
    int bladerf_si5338_write(struct bladerf *dev, uint8_t address, uint8_t
        val);
    int bladerf_lms_read(struct bladerf *dev, uint8_t address, uint8_t
        *val);
    int bladerf_lms_write(struct bladerf *dev, uint8_t address, uint8_t
        val);
    struct bladerf_lms_dc_cals
    {
        int16_t lpf_tuning;
        int16_t tx_lpf_i;
        int16_t tx_lpf_q;
        int16_t rx_lpf_i;
        int16_t rx_lpf_q;
        int16_t dc_ref;
        int16_t rxvga2a_i;
        int16_t rxvga2a_q;
        int16_t rxvga2b_i;
        int16_t rxvga2b_q;
    };
    int bladerf_lms_set_dc_cals(struct bladerf *dev, const struct
        bladerf_lms_dc_cals *dc_cals);
    int bladerf_lms_get_dc_cals(struct bladerf *dev, struct
        bladerf_lms_dc_cals *dc_cals);
    int bladerf_xb_spi_write(struct bladerf *dev, uint32_t val);
    int bladerf_get_bias_tee(struct bladerf *dev, bladerf_channel ch, bool
        *enable);
    int bladerf_set_bias_tee(struct bladerf *dev, bladerf_channel ch, bool
        enable);
    int bladerf_ad9361_read(struct bladerf *dev, uint16_t address, uint8_t
        *val);
    int bladerf_ad9361_write(struct bladerf *dev, uint16_t address,
        uint8_t val);
    int bladerf_ad9361_temperature(struct bladerf *dev, float *val);
    int bladerf_ad9361_get_rssi(struct bladerf *dev, bladerf_channel ch,
        int32_t *pre_rssi, int32_t *sym_rssi);
    int bladerf_adf4002_get_locked(struct bladerf *dev, bool *locked);
    int bladerf_adf4002_get_enable(struct bladerf *dev, bool *enabled);
    int bladerf_adf4002_set_enable(struct bladerf *dev, bool enable);
    int bladerf_adf4002_get_refclk_range(struct bladerf *dev, struct
        bladerf_range *range);
    int bladerf_adf4002_get_refclk(struct bladerf *dev, uint64_t
        *frequency);
    int bladerf_adf4002_set_refclk(struct bladerf *dev, uint64_t
        frequency);
    int bladerf_adf4002_read(struct bladerf *dev, uint8_t address,
        uint32_t *val);
    int bladerf_adf4002_write(struct bladerf *dev, uint8_t address,
        uint32_t val);
    typedef enum
    {
        BLADERF_UNKNOWN,
        BLADERF_PS_DC,
        BLADERF_PS_USB_VBUS
    } bladerf_power_sources;
    int bladerf_get_power_source(struct bladerf *dev,
        bladerf_power_sources *val);
    typedef enum
    {
        CLOCK_SELECT_VCTCXO,
        CLOCK_SELECT_EXTERNAL
    } bladerf_clock_select;
    int bladerf_get_clock_select(struct bladerf *dev, bladerf_clock_select
        *sel);
    int bladerf_set_clock_select(struct bladerf *dev, bladerf_clock_select
        sel);
    int bladerf_get_clock_output(struct bladerf *dev, bool *state);
    int bladerf_set_clock_output(struct bladerf *dev, bool enable);
    typedef enum
    {
        BLADERF_INA219_CONFIGURATION,
        BLADERF_INA219_VOLTAGE_SHUNT,
        BLADERF_INA219_VOLTAGE_BUS,
        BLADERF_INA219_POWER,
        BLADERF_INA219_CURRENT,
        BLADERF_INA219_CALIBRATION
    } bladerf_ina219_register;
    int bladerf_ina219_read(struct bladerf *dev, bladerf_ina219_register
        reg, void *val);
    typedef struct
    {
        uint32_t tx1_rfic_port;
        uint32_t tx1_spdt_port;
        uint32_t tx2_rfic_port;
        uint32_t tx2_spdt_port;
        uint32_t rx1_rfic_port;
        uint32_t rx1_spdt_port;
        uint32_t rx2_rfic_port;
        uint32_t rx2_spdt_port;
    } bladerf_rf_switch_config;
    int bladerf_get_rf_switch_config(struct bladerf *dev,
        bladerf_rf_switch_config *config);
""")

libbladeRF = ffi.dlopen("libbladeRF.so")


###############################################################################


# Python class wrappers for various structures

class ReturnCode(enum.Enum):
    BladeRFError = 0
    UnexpectedError = -1
    RangeError = -2
    InvalError = -3
    MemError = -4
    IOError = -5
    TimeoutError = -6
    NoDevError = -7
    UnsupportedError = -8
    MisalignedError = -9
    ChecksumError = -10
    NoFileError = -11
    UpdateFPGAError = -12
    UpdateFWError = -13
    TimePastError = -14
    QueueFullError = -15
    FPGAOpError = -16
    PermissionError = -17
    WouldBlockError = -18
    NotInitError = -19

    def __str__(self):
        return self.name


class Version(collections.namedtuple("Version", [
                "major", "minor", "patch", "describe"])):
    @staticmethod
    def from_struct(version):
        return Version(version.major, version.minor, version.patch,
                       ffi.string(version.describe).decode())

    def __str__(self):
        return "v{}.{}.{} (\"{}\")".format(*self)


class RationalRate(collections.namedtuple("RationalRate", [
                    "integer", "num", "den"])):
    @staticmethod
    def from_struct(rate):
        return RationalRate(rate.integer, rate.num, rate.den)

    def to_struct(self):
        return ffi.new("struct bladerf_rational_rate *", [
                        self.integer, self.num, self.den])

    struct = property(to_struct)


class Backend(enum.Enum):
    Any = libbladeRF.BLADERF_BACKEND_ANY
    Linux = libbladeRF.BLADERF_BACKEND_LINUX
    LibUSB = libbladeRF.BLADERF_BACKEND_LIBUSB
    Cypress = libbladeRF.BLADERF_BACKEND_CYPRESS
    Dummy = libbladeRF.BLADERF_BACKEND_DUMMY

    def __str__(self):
        return ffi.string(libbladeRF.bladerf_backend_str(self.value)).decode()


class DevInfo(collections.namedtuple("DevInfo", [
                "backend", "serial", "usb_bus", "usb_addr", "instance"])):
    @staticmethod
    def from_struct(devinfo):
        return DevInfo(Backend(devinfo.backend),
                       bytes(ffi.string(devinfo.serial)),
                       devinfo.usb_bus,
                       devinfo.usb_addr,
                       devinfo.instance)

    def to_struct(self):
        return ffi.new("struct bladerf_devinfo *", [
                        Backend(self.backend).value, self.serial, self.usb_bus,
                        self.usb_addr, self.instance])

    struct = property(to_struct)

    @property
    def devstr(self):
        d = self._asdict()
        d['serial'] = self.serial_str
        return ("{backend}:device={usb_bus}:{usb_addr} instance={instance}"
                " serial={serial}".format(**d))

    @property
    def serial_str(self):
        return self.serial.decode()

    def __str__(self):
        return ("Device Information\n" +
                "    backend  {}\n".format(self.backend) +
                "    serial   {}\n".format(self.serial_str) +
                "    usb_bus  {}\n".format(self.usb_bus) +
                "    usb_addr {}\n".format(self.usb_addr) +
                "    instance {}".format(self.instance))

    def __repr__(self):
        return '<DevInfo({})>'.format(self.devstr)


class Range(collections.namedtuple("Range", ["min", "max", "step", "scale"])):
    @staticmethod
    def from_struct(_range):
        return Range(_range.min, _range.max, _range.step, _range.scale)

    def __str__(self):
        return ("Range\n" +
                "    min   {}\n".format(self.min) +
                "    max   {}\n".format(self.max) +
                "    step  {}\n".format(self.step) +
                "    scale {}\n".format(self.scale))

    def __repr__(self):
        return '<Range(min={min},max={max},step={step},scale={scale})>'.format(
            **self._asdict())


class DeviceSpeed(enum.Enum):
    Unknown = libbladeRF.BLADERF_DEVICE_SPEED_UNKNOWN
    High = libbladeRF.BLADERF_DEVICE_SPEED_HIGH
    Super = libbladeRF.BLADERF_DEVICE_SPEED_SUPER


class GainMode(enum.Enum):
    Default = libbladeRF.BLADERF_GAIN_DEFAULT
    Manual = libbladeRF.BLADERF_GAIN_MGC
    FastAttack_AGC = libbladeRF.BLADERF_GAIN_FASTATTACK_AGC
    SlowAttack_AGC = libbladeRF.BLADERF_GAIN_SLOWATTACK_AGC
    Hybrid_AGC = libbladeRF.BLADERF_GAIN_HYBRID_AGC

    def __str__(self):
        return self.name

    def __int__(self):
        return self.value


class Direction(enum.Enum):
    TX = libbladeRF.BLADERF_TX
    RX = libbladeRF.BLADERF_RX


class ChannelLayout(enum.Enum):
    RX_X1 = libbladeRF.BLADERF_RX_X1
    TX_X1 = libbladeRF.BLADERF_TX_X1
    RX_X2 = libbladeRF.BLADERF_RX_X2
    TX_X2 = libbladeRF.BLADERF_TX_X2


class Correction(enum.Enum):
    DCOFF_I = libbladeRF.BLADERF_CORR_DCOFF_I
    DCOFF_Q = libbladeRF.BLADERF_CORR_DCOFF_Q
    PHASE = libbladeRF.BLADERF_CORR_PHASE
    GAIN = libbladeRF.BLADERF_CORR_GAIN


class Format(enum.Enum):
    SC16_Q11 = libbladeRF.BLADERF_FORMAT_SC16_Q11
    SC16_Q11_META = libbladeRF.BLADERF_FORMAT_SC16_Q11_META


class Loopback(enum.Enum):
    Firmware = libbladeRF.BLADERF_LB_FIRMWARE
    BB_TXLPF_RXVGA2 = libbladeRF.BLADERF_LB_BB_TXLPF_RXVGA2
    BB_TXVGA1_RXVGA2 = libbladeRF.BLADERF_LB_BB_TXVGA1_RXVGA2
    BB_TXLPF_RXLPF = libbladeRF.BLADERF_LB_BB_TXLPF_RXLPF
    BB_TXVGA1_RXLPF = libbladeRF.BLADERF_LB_BB_TXVGA1_RXLPF
    RF_LNA1 = libbladeRF.BLADERF_LB_RF_LNA1
    RF_LNA2 = libbladeRF.BLADERF_LB_RF_LNA2
    RF_LNA3 = libbladeRF.BLADERF_LB_RF_LNA3
    Disabled = libbladeRF.BLADERF_LB_NONE
    AD9361_BIST = libbladeRF.BLADERF_LB_AD9361_BIST

    def __str__(self):
        return self.name


class RXMux(enum.Enum):
    Invalid = libbladeRF.BLADERF_RX_MUX_INVALID
    Baseband = libbladeRF.BLADERF_RX_MUX_BASEBAND
    Counter_12bit = libbladeRF.BLADERF_RX_MUX_12BIT_COUNTER
    Counter_32bit = libbladeRF.BLADERF_RX_MUX_32BIT_COUNTER
    Digital_Loopback = libbladeRF.BLADERF_RX_MUX_DIGITAL_LOOPBACK

    def __str__(self):
        return self.name


class ClockSelect(enum.Enum):
    Unknown = -99
    VCTCXO = libbladeRF.CLOCK_SELECT_VCTCXO
    External = libbladeRF.CLOCK_SELECT_EXTERNAL

    def __str__(self):
        return self.name


class RSSI(collections.namedtuple("RSSI", ["preamble", "symbol"])):
    def __str__(self):
        return ("RSSI\n" +
                "    preamble {preamble} dB\n" +
                "    symbol   {symbol} dB\n").format(**self._asdict())

    def __repr__(self):
        return ("<RSSI(preamble={preamble}," +
                "symbol={symbol})>").format(**self._asdict())


class PowerSource(enum.Enum):
    Unknown = libbladeRF.BLADERF_UNKNOWN
    DC_Barrel = libbladeRF.BLADERF_PS_DC
    USB_VBUS = libbladeRF.BLADERF_PS_USB_VBUS

    def __str__(self):
        return self.name


class INA219_Register(enum.Enum):
    Configuration = libbladeRF.BLADERF_INA219_CONFIGURATION
    Voltage_shunt = libbladeRF.BLADERF_INA219_VOLTAGE_SHUNT
    Voltage_bus = libbladeRF.BLADERF_INA219_VOLTAGE_BUS
    Power = libbladeRF.BLADERF_INA219_POWER
    Current = libbladeRF.BLADERF_INA219_CURRENT
    Calibration = libbladeRF.BLADERF_INA219_CALIBRATION

    @property
    def ctype(self):
        """C type definition for the pointer to the returned value."""
        if self in [self.Configuration, self.Calibration]:
            return "uint16_t *"
        else:
            return "float *"


###############################################################################


class BladeRFError(Exception):
    """A general libbladeRF exception occurred"""
    def __init__(self, code=0, msg=None):
        if isinstance(code, str):
            # SubclassedError("user message")
            msg = code
            code = 0

        if code == 0:
            i_am = self.__class__.__name__
            code = getattr(ReturnCode, i_am).value

        self.errstr = ffi.string(libbladeRF.bladerf_strerror(code)).decode()

        if msg is not None:
            self.errstr += " (" + msg + ")"

    def __str__(self):
        return self.errstr


class UnexpectedError(BladeRFError):
    """An unexpected failure occurred"""


class RangeError(BladeRFError):
    """Provided parameter is out of range"""


class InvalError(BladeRFError):
    """Invalid operation/parameter"""


class MemError(BladeRFError):
    """Memory allocation error"""


class IOError(BladeRFError):
    """File/Device I/O error"""


class TimeoutError(BladeRFError):
    """Operation timed out"""


class NoDevError(BladeRFError):
    """No device(s) available"""


class UnsupportedError(BladeRFError):
    """Operation not supported"""


class MisalignedError(BladeRFError):
    """Misaligned flash access"""


class ChecksumError(BladeRFError):
    """Invalid checksum"""


class NoFileError(BladeRFError):
    """File not found"""


class UpdateFPGAError(BladeRFError):
    """An FPGA update is required"""


class UpdateFWError(BladeRFError):
    """A firmware update is required"""


class TimePastError(BladeRFError):
    """Requested timestamp is in the past"""


class QueueFullError(BladeRFError):
    """Could not enqueue data into full queue"""


class FPGAOpError(BladeRFError):
    """An FPGA operation reported failure"""


class PermissionError(BladeRFError):
    """Insufficient permissions for the requested operation"""


class WouldBlockError(BladeRFError):
    """Operation would block, but has been requested to be non-blocking."""


class NotInitError(BladeRFError):
    """Device insufficiently initialized for operation"""


def _check_error(err):
    """If the result code indicates an error, raise an exception"""
    if err < 0:
        try:
            errorval = ReturnCode(err)
        except ValueError:
            errorval = ReturnCode(0)

        raise globals()[errorval.name](err)


###############################################################################


def set_verbosity(level):
    libbladeRF.bladerf_log_set_verbosity(level)


def version():
    version = ffi.new("struct bladerf_version *")
    libbladeRF.bladerf_version(version)
    return Version.from_struct(version)


def get_device_list():
    devices = ffi.new("struct bladerf_devinfo *[1]")
    ret = libbladeRF.bladerf_get_device_list(devices)
    _check_error(ret)
    devinfos = [DevInfo.from_struct(devices[0][i]) for i in range(ret)]
    libbladeRF.bladerf_free_device_list(devices[0])
    return devinfos


def get_bootloader_list():
    devices = ffi.new("struct bladerf_devinfo *[1]")
    ret = libbladeRF.bladerf_get_bootloader_list(devices)
    _check_error(ret)
    devinfos = [DevInfo.from_struct(devices[0][i]) for i in range(ret)]
    libbladeRF.bladerf_free_device_list(devices[0])
    return devinfos


def load_fw_from_bootloader(device_identifier=None, backend=0, bus=0, addr=0,
                            file=None):
    ret = libbladeRF.bladerf_load_fw_from_bootloader(
        device_identifier.encode(), backend, bus, addr, file.encode())
    _check_error(ret)


###############################################################################


RX = 0x0
TX = 0x1


def CHANNEL_RX(ch):
    return (ch << 1) | RX


def CHANNEL_TX(ch):
    return (ch << 1) | TX


# defaults for ADF4002 on bladeRF 2
BLADERF_VCTCXO_FREQUENCY = 38.4e6
BLADERF_REFIN_DEFAULT = 10.0e6


###############################################################################


class BladeRF:
    """Python class for interacting with bladeRF boards.

    Example usage:

    >>> d = bladerf.BladeRF()
    >>> d.board_name
    'bladerf1'
    """

    def __init__(self, device_identifier=None, devinfo=None):
        self.dev = ffi.new("struct bladerf *[1]")
        self.open(device_identifier, devinfo)

    def __repr__(self):
        return '<BladeRF({!r})>'.format(self.devinfo)

    # Open, close, devinfo

    def open(self, device_identifier=None, devinfo=None):
        if devinfo is not None:
            ret = libbladeRF.bladerf_open_with_devinfo(self.dev,
                                                       devinfo.struct)
        elif device_identifier is not None:
            ret = libbladeRF.bladerf_open(self.dev, device_identifier.encode())
        else:
            ret = libbladeRF.bladerf_open(self.dev, ffi.NULL)
        _check_error(ret)

    def close(self):
        libbladeRF.bladerf_close(self.dev[0])

    def get_devinfo(self):
        devinfo = ffi.new("struct bladerf_devinfo *")
        ret = libbladeRF.bladerf_get_devinfo(self.dev[0], devinfo)
        _check_error(ret)
        return DevInfo.from_struct(devinfo)

    devinfo = property(get_devinfo,
                       doc="Device information as a DevInfo structure")

    # Device properties

    def get_device_speed(self):
        return DeviceSpeed(libbladeRF.bladerf_device_speed(self.dev[0]))

    device_speed = property(get_device_speed,
                            doc="USB speed of the open device")

    def get_serial(self):
        serial = ffi.new("char []", libbladeRF.BLADERF_SERIAL_LENGTH)
        ret = libbladeRF.bladerf_get_serial(self.dev[0], serial)
        _check_error(ret)
        return ffi.string(serial).decode()

    serial = property(get_serial, doc="Serial number of the open device")

    def get_fpga_size(self):
        fpga_size = ffi.new("bladerf_fpga_size *")
        ret = libbladeRF.bladerf_get_fpga_size(self.dev[0], fpga_size)
        _check_error(ret)
        return fpga_size[0]

    fpga_size = property(get_fpga_size, doc="FPGA size in kLE")

    def is_fpga_configured(self):
        ret = libbladeRF.bladerf_is_fpga_configured(self.dev[0])
        _check_error(ret)
        return bool(ret)

    fpga_configured = property(is_fpga_configured,
                               doc="True if the device's FPGA is configured")

    def get_fpga_version(self):
        version = ffi.new("struct bladerf_version *")
        ret = libbladeRF.bladerf_fpga_version(self.dev[0], version)
        _check_error(ret)
        return Version.from_struct(version)

    fpga_version = property(get_fpga_version, doc="FPGA version information")

    def get_fw_version(self):
        version = ffi.new("struct bladerf_version *")
        ret = libbladeRF.bladerf_fw_version(self.dev[0], version)
        _check_error(ret)
        return Version.from_struct(version)

    fw_version = property(get_fw_version, doc="Firmware version information")

    def get_board_name(self):
        board_name = libbladeRF.bladerf_get_board_name(self.dev[0])
        return ffi.string(board_name).decode()

    board_name = property(get_board_name,
                          doc="The board model name, as a string")

    def get_channel_count(self, is_tx=False):
        return libbladeRF.bladerf_get_channel_count(self.dev[0], is_tx)

    @property
    def rx_channel_count(self):
        """Number of RX channels on the device"""
        return self.get_channel_count(False)

    @property
    def tx_channel_count(self):
        """Number of TX channels on the device"""
        return self.get_channel_count(True)

    # Enable/Disable

    def enable_module(self, ch, enable):
        ret = libbladeRF.bladerf_enable_module(self.dev[0], ch, bool(enable))
        _check_error(ret)

    # Gain

    def set_gain(self, ch, gain):
        ret = libbladeRF.bladerf_set_gain(self.dev[0], ch, gain)
        _check_error(ret)

    def get_gain(self, ch):
        gain = ffi.new("int *")
        ret = libbladeRF.bladerf_get_gain(self.dev[0], ch, gain)
        _check_error(ret)
        return gain[0]

    def set_gain_mode(self, ch, mode):
        ret = libbladeRF.bladerf_set_gain_mode(self.dev[0], ch, int(mode))
        _check_error(ret)

    def get_gain_mode(self, ch):
        try:
            mode = ffi.new("bladerf_gain_mode *")
            ret = libbladeRF.bladerf_get_gain_mode(self.dev[0], ch, mode)
            _check_error(ret)
            return GainMode(mode[0])
        except UnsupportedError:
            return None

    def get_gain_modes(self, ch):
        ret = libbladeRF.bladerf_get_gain_modes(self.dev[0], ch, ffi.NULL)
        _check_error(ret)
        modes_arr = ffi.new("struct bladerf_gain_modes *[]", ret)
        ret = libbladeRF.bladerf_get_gain_modes(self.dev[0], ch, modes_arr)
        _check_error(ret)
        return [GainMode(modes_arr[0][i].mode) for i in range(ret)]

    def get_gain_range(self, ch):
        gain_range = ffi.new("struct bladerf_range *")
        ret = libbladeRF.bladerf_get_gain_range(self.dev[0], ch, gain_range)
        _check_error(ret)
        return Range.from_struct(gain_range)

    def set_gain_stage(self, ch, stage, gain):
        ret = libbladeRF.bladerf_set_gain_stage(self.dev[0], ch,
                                                stage.encode(), gain)
        _check_error(ret)

    def get_gain_stage(self, ch, stage):
        gain = ffi.new("int *")
        ret = libbladeRF.bladerf_get_gain_stage(self.dev[0], ch,
                                                stage.encode(), gain)
        _check_error(ret)
        return gain[0]

    def get_gain_stage_range(self, ch, stage):
        gain_range = ffi.new("struct bladerf_range *")
        ret = libbladeRF.bladerf_get_gain_stage_range(self.dev[0], ch,
                                                      stage.encode(),
                                                      gain_range)
        _check_error(ret)
        return Range.from_struct(gain_range)

    def get_gain_stages(self, ch):
        ret = libbladeRF.bladerf_get_gain_stages(self.dev[0], ch, ffi.NULL, 0)
        _check_error(ret)
        stages_arr = ffi.new("const char *[]", ret)
        ret = libbladeRF.bladerf_get_gain_stages(self.dev[0], ch, stages_arr,
                                                 ret)
        _check_error(ret)
        return [ffi.string(stages_arr[i]).decode() for i in range(ret)]

    # Sample rate

    def set_sample_rate(self, ch, rate):
        actual_rate = ffi.new("unsigned int *")
        ret = libbladeRF.bladerf_set_sample_rate(self.dev[0], ch, int(rate),
                                                 actual_rate)
        _check_error(ret)
        return actual_rate[0]

    def set_rational_sample_rate(self, ch, rational_rate):
        raise NotImplementedError()

    def get_sample_rate(self, ch):
        rate = ffi.new("unsigned int *")
        ret = libbladeRF.bladerf_get_sample_rate(self.dev[0], ch, rate)
        _check_error(ret)
        return rate[0]

    def get_rational_sample_rate(self, ch):
        raise NotImplementedError()

    def get_sample_rate_range(self, ch):
        sample_rate_range = ffi.new("struct bladerf_range *")
        ret = libbladeRF.bladerf_get_sample_rate_range(self.dev[0], ch,
                                                       sample_rate_range)
        _check_error(ret)
        return Range.from_struct(sample_rate_range)

    # Bandwidth

    def set_bandwidth(self, ch, bandwidth):
        actual_bandwidth = ffi.new("unsigned int *")
        ret = libbladeRF.bladerf_set_bandwidth(self.dev[0], ch, int(bandwidth),
                                               actual_bandwidth)
        _check_error(ret)
        return actual_bandwidth[0]

    def get_bandwidth(self, ch):
        bandwidth = ffi.new("unsigned int *")
        ret = libbladeRF.bladerf_get_bandwidth(self.dev[0], ch, bandwidth)
        _check_error(ret)
        return bandwidth[0]

    def get_bandwidth_range(self, ch):
        bandwidth_range = ffi.new("struct bladerf_range *")
        ret = libbladeRF.bladerf_get_bandwidth_range(self.dev[0], ch,
                                                     bandwidth_range)
        _check_error(ret)
        return Range.from_struct(bandwidth_range)

    # Frequency

    def set_frequency(self, ch, frequency):
        ret = libbladeRF.bladerf_set_frequency(self.dev[0], ch, int(frequency))
        _check_error(ret)

    def get_frequency(self, ch):
        frequency = ffi.new("uint64_t *")
        ret = libbladeRF.bladerf_get_frequency(self.dev[0], ch, frequency)
        _check_error(ret)
        return frequency[0]

    def select_band(self, ch, frequency):
        ret = libbladeRF.bladerf_select_band(self.dev[0], ch, int(frequency))
        _check_error(ret)

    def get_frequency_range(self, ch):
        frequency_range = ffi.new("struct bladerf_range *")
        ret = libbladeRF.bladerf_get_frequency_range(self.dev[0], ch,
                                                     frequency_range)
        _check_error(ret)
        return Range.from_struct(frequency_range)

    # RF Ports

    def set_rf_port(self, ch, port):
        ret = libbladeRF.bladerf_set_rf_port(self.dev[0], ch, port.encode())
        _check_error(ret)

    def get_rf_port(self, ch):
        try:
            port = ffi.new("const char *[1]")
            ret = libbladeRF.bladerf_get_rf_port(self.dev[0], ch, port)
            _check_error(ret)
            return ffi.string(port[0]).decode()
        except UnsupportedError:
            return None

    def get_rf_ports(self, ch):
        try:
            count = libbladeRF.bladerf_get_rf_ports(self.dev[0], ch, ffi.NULL,
                                                    0)
            _check_error(count)
            ports_arr = ffi.new("const char *[]", count)
            ret = libbladeRF.bladerf_get_rf_ports(self.dev[0], ch, ports_arr,
                                                  count)
            _check_error(ret)
            return [ffi.string(ports_arr[i]).decode() for i in range(ret)]
        except UnsupportedError:
            return []

    # Sample Loopback

    def get_loopback_modes(self):
        ret = libbladeRF.bladerf_get_loopback_modes(self.dev[0], ffi.NULL)
        _check_error(ret)
        modes_arr = ffi.new("struct bladerf_loopback_modes *[]", ret)
        ret = libbladeRF.bladerf_get_loopback_modes(self.dev[0], modes_arr)
        _check_error(ret)
        return [Loopback(modes_arr[0][i].mode) for i in range(ret)]

    loopback_modes = property(get_loopback_modes,
                              doc="Supported loopback modes")

    def is_loopback_mode_supported(self, lb):
        if isinstance(lb, Loopback):
            lb = lb.value
        ret = libbladeRF.bladerf_is_loopback_mode_supported(self.dev[0], lb)
        _check_error(ret)
        return bool(ret)

    def get_loopback(self):
        lb = ffi.new("bladerf_loopback *")
        ret = libbladeRF.bladerf_get_loopback(self.dev[0], lb)
        _check_error(ret)
        return Loopback(lb[0])

    def set_loopback(self, lb):
        if isinstance(lb, Loopback):
            lb = lb.value
        ret = libbladeRF.bladerf_set_loopback(self.dev[0], lb)
        _check_error(ret)

    loopback = property(get_loopback, set_loopback, doc="Loopback selection")

    # Trigger TBD

    # Sample RX Mux

    def get_rx_mux(self):
        mux = ffi.new("bladerf_rx_mux *")
        ret = libbladeRF.bladerf_get_rx_mux(self.dev[0], mux)
        _check_error(ret)
        return RXMux(mux[0])

    def set_rx_mux(self, rx_mux):
        if isinstance(rx_mux, RXMux):
            rx_mux = rx_mux.value
        ret = libbladeRF.bladerf_set_rx_mux(self.dev[0], rx_mux)
        _check_error(ret)

    rx_mux = property(get_rx_mux, set_rx_mux, doc="RX Multiplexer selection")

    # DC/Phase/Gain Correction

    def get_correction(self, ch, corr):
        value = ffi.new("int16_t *")
        ret = libbladeRF.bladerf_get_correction(self.dev[0], ch, corr.value,
                                                value)
        _check_error(ret)
        return value[0]

    def set_correction(self, ch, corr, value):
        ret = libbladeRF.bladerf_set_correction(self.dev[0], ch, corr.value,
                                                value)
        _check_error(ret)

    # Streaming format

    def interleave_stream_buffer(self, layout, format, buffer_size, samples):
        raise NotImplementedError()

    def deinterleave_stream_buffer(self, layout, format, buffer_size, samples):
        raise NotImplementedError()

    # Streaming

    def sync_config(self, layout, fmt, num_buffers, buffer_size, num_transfers,
                    stream_timeout):
        if fmt != Format.SC16_Q11:
            raise NotImplementedError("Format not supported by binding.")

        ret = libbladeRF.bladerf_sync_config(self.dev[0],
                                             layout.value,
                                             fmt.value,
                                             num_buffers,
                                             buffer_size,
                                             num_transfers,
                                             stream_timeout)
        _check_error(ret)

    def sync_tx(self, buf, num_samples, timeout_ms=None):
        ret = libbladeRF.bladerf_sync_tx(self.dev[0],
                                         ffi.from_buffer(buf),
                                         num_samples,
                                         ffi.NULL,
                                         timeout_ms or 0)
        _check_error(ret)

    def sync_rx(self, buf, num_samples, timeout_ms=None):
        ret = libbladeRF.bladerf_sync_rx(self.dev[0],
                                         ffi.from_buffer(buf),
                                         num_samples,
                                         ffi.NULL,
                                         timeout_ms or 0)
        _check_error(ret)

    # FPGA/Firmware Loading/Flashing

    def load_fpga(self, image_path):
        ret = libbladeRF.bladerf_load_fpga(self.dev[0], image_path.encode())
        _check_error(ret)

    def flash_fpga(self, image_path):
        ret = libbladeRF.bladerf_flash_fpga(self.dev[0], image_path.encode())
        _check_error(ret)

    def erase_stored_fpga(self):
        ret = libbladeRF.bladerf_erase_stored_fpga(self.dev[0])
        _check_error(ret)

    def flash_firmware(self, image_path):
        ret = libbladeRF.bladerf_flash_firmware(self.dev[0],
                                                image_path.encode())
        _check_error(ret)

    def device_reset(self):
        ret = libbladeRF.bladerf_device_reset(self.dev[0])
        _check_error(ret)

    # VCTCXO Tamer Mode

    def set_vctcxo_tamer_mode(self, mode):
        raise NotImplementedError()

    def get_vctcxo_tamer_mode(self):
        raise NotImplementedError()

    vctcxo_tamer_mode = property(get_vctcxo_tamer_mode, set_vctcxo_tamer_mode)

    def get_vctcxo_trim(self):
        raise NotImplementedError()

    vctcxo = property(get_vctcxo_trim)

    # Tuning Mode

    def set_tuning_mode(self, mode):
        raise NotImplementedError()

    def get_tuning_mode(self):
        raise NotImplementedError()

    tuning_mode = property(get_tuning_mode, set_tuning_mode)

    # Bias tee

    def get_bias_tee(self, ch):
        try:
            state = ffi.new("bool *")
            ret = libbladeRF.bladerf_get_bias_tee(self.dev[0], ch, state)
            _check_error(ret)
            return bool(state[0])
        except UnsupportedError:
            return None

    def set_bias_tee(self, ch, enable):
        ret = libbladeRF.bladerf_set_bias_tee(self.dev[0], ch, enable)
        _check_error(ret)

    # AD9361 RFIC

    def get_ad9361_temperature(self):
        try:
            val = ffi.new("float *")
            ret = libbladeRF.bladerf_ad9361_temperature(self.dev[0], val)
            _check_error(ret)
            return val[0]
        except UnsupportedError:
            return None

    ad9361_temperature = property(get_ad9361_temperature,
                                  doc="AD9361 RFIC temperature")

    def get_ad9361_rssi(self, ch):
        try:
            preamble = ffi.new("int32_t *")
            symbol = ffi.new("int32_t *")
            ret = libbladeRF.bladerf_ad9361_get_rssi(self.dev[0], ch,
                                                     preamble, symbol)
            _check_error(ret)
            return RSSI(preamble[0], symbol[0])
        except UnsupportedError:
            return None

    # ADF4002 Phase Detector/Frequency Synthesizer

    def get_adf4002_locked(self):
        try:
            locked = ffi.new("bool *")
            ret = libbladeRF.bladerf_adf4002_get_locked(self.dev[0], locked)
            _check_error(ret)
            return bool(locked[0])
        except UnsupportedError:
            return None

    adf4002_locked = property(get_adf4002_locked,
                              doc="ADF4002 PLL lock indication")

    def get_adf4002_enable(self):
        try:
            enable = ffi.new("bool *")
            ret = libbladeRF.bladerf_adf4002_get_enable(self.dev[0], enable)
            _check_error(ret)
            return bool(enable[0])
        except UnsupportedError:
            return None

    def set_adf4002_enable(self, enable):
        ret = libbladeRF.bladerf_adf4002_set_enable(self.dev[0], enable)
        _check_error(ret)

    adf4002_enable = property(get_adf4002_enable, set_adf4002_enable,
                              doc="ADF4002 Enable")

    def get_adf4002_refclk(self):
        try:
            freq = ffi.new("uint64_t *")
            ret = libbladeRF.bladerf_adf4002_get_refclk(self.dev[0], freq)
            _check_error(ret)
            return int(freq[0])
        except UnsupportedError:
            return None

    def set_adf4002_refclk(self, freq):
        ret = libbladeRF.bladerf_adf4002_set_refclk(self.dev[0], freq)
        _check_error(ret)

    adf4002_refclk = property(get_adf4002_refclk, set_adf4002_refclk,
                              doc="ADF4002 Reference Clock frequency")

    # Power source

    def get_power_source(self):
        try:
            val = ffi.new("bladerf_power_sources *")
            ret = libbladeRF.bladerf_get_power_source(self.dev[0], val)
            _check_error(ret)
            return PowerSource(val[0])
        except UnsupportedError:
            return PowerSource.Unknown

    power_source = property(get_power_source,
                            doc="Active power source for device")

    # Clock select

    def get_clock_select(self):
        try:
            sel = ffi.new("bladerf_clock_select *")
            ret = libbladeRF.bladerf_get_clock_select(self.dev[0], sel)
            _check_error(ret)
            return ClockSelect(sel[0])
        except UnsupportedError:
            return ClockSelect.Unknown

    def set_clock_select(self, sel):
        if isinstance(sel, ClockSelect):
            sel = sel.value
        ret = libbladeRF.bladerf_set_clock_select(self.dev[0], sel)
        _check_error(ret)

    clock_select = property(get_clock_select, set_clock_select,
                            doc="System clock input selection")

    # Clock output

    def get_clock_output(self):
        try:
            state = ffi.new("bool *")
            ret = libbladeRF.bladerf_get_clock_output(self.dev[0], state)
            _check_error(ret)
            return bool(state[0])
        except UnsupportedError:
            return None

    def set_clock_output(self, enable):
        ret = libbladeRF.bladerf_set_clock_output(self.dev[0], enable)
        _check_error(ret)

    clock_output = property(get_clock_output, set_clock_output,
                            doc="Clock output enable")

    # INA219 current/power monitor

    def get_ina219_register(self, reg):
        try:
            if not isinstance(reg, INA219_Register):
                reg = INA219_Register(reg)
            val = ffi.new(reg.ctype)
            ret = libbladeRF.bladerf_ina219_read(self.dev[0], reg.value, val)
            _check_error(ret)
            return val[0]
        except UnsupportedError:
            return None

    @property
    def bus_voltage(self):
        """Main power bus voltage, in Volts"""
        return self.get_ina219_register(INA219_Register.Voltage_bus)

    @property
    def bus_current(self):
        """Main power bus current, in Amps"""
        return self.get_ina219_register(INA219_Register.Current)

    @property
    def bus_power(self):
        """Main power bus power, in Watts"""
        return self.get_ina219_register(INA219_Register.Power)

    # Convenience objects

    class _Channel:
        """Container for bladeRF channel properties"""

        def __init__(self, dev, channel):
            self.dev = dev
            self.channel = channel

            if (channel >> 1) not in range(dev.get_channel_count(self.is_tx)):
                raise UnsupportedError("Invalid channel: " + str(channel))

        def __str__(self):
            return "Channel {}{}".format(
                "TX" if self.is_tx else "RX", (self.channel >> 1) + 1)

        def __repr__(self):
            return '<Channel({},CHANNEL_{}({}))>'.format(
                repr(self.dev), "TX" if self.is_tx else "RX",
                self.channel >> 1)

        @property
        def is_tx(self):
            """Returns True if this is a TX channel, False otherwise"""
            return bool(self.channel & TX)

        @property
        def gain(self):
            """Gain, in dB"""
            return self.dev.get_gain(self.channel)

        @gain.setter
        def gain(self, value):
            return self.dev.set_gain(self.channel, value)

        @property
        def gain_mode(self):
            """Gain mode"""
            return self.dev.get_gain_mode(self.channel)

        @gain_mode.setter
        def gain_mode(self, value):
            return self.dev.set_gain_mode(self.channel, value)

        @property
        def gain_modes(self):
            """List of supported gain modes"""
            return self.dev.get_gain_modes(self.channel)

        @property
        def rssi(self):
            """RSSI report from RFIC"""
            return self.dev.get_ad9361_rssi(self.channel)

        @property
        def preamble_rssi(self):
            """Preamble RSSI reading (latched at algorithm reset)"""
            if self.rssi is not None:
                return self.rssi.preamble
            else:
                return None

        @property
        def symbol_rssi(self):
            """Symbol RSSI reading (most recent value)"""
            if self.rssi is not None:
                return self.rssi.symbol
            else:
                return None

        @property
        def sample_rate(self):
            """Sample rate, in samples/second"""
            return self.dev.get_sample_rate(self.channel)

        @sample_rate.setter
        def sample_rate(self, value):
            return self.dev.set_sample_rate(self.channel, value)

        @property
        def sample_rate_range(self):
            """Range of sample rates supported by this channel"""
            return self.dev.get_sample_rate_range(self.channel)

        @property
        def bandwidth(self):
            """Channel bandwidth in Hz"""
            return self.dev.get_bandwidth(self.channel)

        @bandwidth.setter
        def bandwidth(self, value):
            return self.dev.set_bandwidth(self.channel, value)

        @property
        def bandwidth_range(self):
            """Range of bandwidths supported by this channel"""
            return self.dev.get_bandwidth_range(self.channel)

        @property
        def frequency(self):
            """Frequency in Hz"""
            return self.dev.get_frequency(self.channel)

        @frequency.setter
        def frequency(self, value):
            return self.dev.set_frequency(self.channel, value)

        @property
        def frequency_range(self):
            """Range of frequencies supported by this channel"""
            return self.dev.get_frequency_range(self.channel)

        @property
        def rf_port(self):
            """Active RF port"""
            return self.dev.get_rf_port(self.channel)

        @rf_port.setter
        def rf_port(self, value):
            return self.dev.set_rf_port(self.channel, value)

        @property
        def rf_ports(self):
            """List of available RF ports"""
            return self.dev.get_rf_ports(self.channel)

        @property
        def bias_tee(self):
            """Bias-T control"""
            return self.dev.get_bias_tee(self.channel)

        @bias_tee.setter
        def bias_tee(self, value):
            return self.dev.set_bias_tee(self.channel, value)

        def set_enable(self, value):
            return self.dev.enable_module(self.channel, value)

        enable = property(fset=set_enable, doc="Enable/disable RF chain")

    def Channel(self, ch):
        """Returns an object for a given subchannel.

        Usage:
        >>> d = bladerf.BladeRF()
        >>> rx = d.Channel(bladerf.CHANNEL_RX(0))

        See help(bladerf.BladeRF._Channel) or help(rx) for more information.
        """
        return self._Channel(self, ch)
